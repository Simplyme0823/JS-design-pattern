<body>
    <script>
        //自己写的
        const event = {}
        event.cache = {}
        event.on = function (e, handler) {
            if (event.cache[e]) {
                event.cache[e].push(handler)
            } else {
                event.cache[e] = []
                event.cache[e].push(handler)
            }
        }
        event.off = function () {
            if (arguments.length == 0) {
                event.cache = {}
            } else if (arguments.length == 1) {
                if (event.cache[arguments[1]]) {
                    event.cache[arguments[1]] = []
                }
            } else if (arguments.length == 2) {
                if (event.cache[arguments[1]]) {
                    event.cache[arguments[1]] = cache[arguments[1]].filter(handler => handler !== arguments[2])
                }
            }
        }
        event.emit = function (e, value) {
            if (event.cache[e]) {
                event.cache[e].forEach(item => {
                    item.call(this, value)
                })
            }
        }
        const handle = function () { console.log(this) }
        event.on('msg', handle)
        event.emit('msg')

        //书上的增加了离线缓存及命名空间

        var myEvent = (function () {
            var global = this,  //window
                myEvent,
                _default = 'default'
            //立即运行函数
            myEvent = function () {
                var _listen,
                    _create,
                    _trigger,
                    _remove,
                    _slice = Array.prototype.splice,
                    _shift = Array.prototype.shift,
                    _unshift = Array.prototype.unshift,
                    namespaceCache = {}
                    find,

                    _listen = function (key, fn, cache) {
                        if (!cache[key]) {
                            cache[key] = []
                        }
                        cache[key].push(fn)
                    }

                _remove = function (key, cache, fn) {
                    if (cache[key]) {
                        if (fn) {
                            //倒叙
                            for (var i = cache[key].length; i >= 0; i--) {
                                if (cache[key][i] === fn) {
                                    cache[key].splice(i, 1)
                                }
                            }
                        }
                    } else {
                        cache[key] = []
                    }
                }

                _trigger = function () {
                    var cache = _shift.call(arguments)
                    key = _shift.call(arguments)
                    args = arguments
                    _self = this
                    ret
                    //时间对应的缓存数组
                    stack = cache[key]
                    if (!stack || !stack.length) {
                        return
                    }
                    //遍历
                    return each(stack, function () {
                        return this.apply(_self, args)
                    })
                }
                each = function (ary, fn) {
                    var ret;
                    for (var i = 0, l = ary.length; i < l; i++) {
                        var n = ary[i]
                        ret = fn.call(n, i, n)
                    }
                    return ret
                }

                //create是为了创造命名空间的
                _create = function (namespace) {
                    var namespace = namespace || _default;
                    //每个cache都有以事件名为key, 由handler们组成的数组为value的对象
                    var cache = {}
                    var offlineStack = [] //先trigger后listen的事件

                    //每一个namespace都有一个ret对象
                    var ret = {
                        //last是只关注离线函数作用栈内的最后一个函数
                        listen: function (key, fn, last) {
                            _listen(key, fn, cache)
                            if (offlineStack === null) {
                                return
                            }
                            if (last === 'last') {
                                offlineStack.length && offlineStack.pop()() 
                            } else {
                                //调用cache内的handlers
                                each(offlineStack, function () {
                                    //这里用this()
                                    //在each中会用call强制绑定一个函数对象，this就会指向那个函数对象
                                    this()
                                })
                            }
                            offlineStack = null
                        },

                        one: function (key, fn, last) {
                            _remove(key, cache)
                            this.listen(key, fn, last)
                        },

                        remove: function (key, fn) {
                            _remove(key, cache, fn)
                        },

                        trigger: function () {
                            var fn,
                                args,
                                _self = this
                            _unshift.call(arguments, cache)
                            args = arguments
                            fn = function () {
                                return _trigger.apply(_self, args)
                            }
                            if (offlineStack) {
                                return offlineStack.push(fn)
                            }
                            return fn()
                        }
                    }
                    return namespace ?
                        (namespaceCache[namespace]
                            ? namespaceCache[namespace]
                            : namespaceCache[namespace] = ret)
                        : ret
                }

                //这部分是真正的myEvent
                //每次都调用create是为了创造命名空间，防止事件过多，互相干扰
                return {
                    create: _create,
                    on: function (key, fn, last) {
                        var event = this.create()
                        event.one(key, fn, last)
                    },
                    remove: function (key, fn) {
                        var event = this.create()
                        event.remove()
                    },
                    listen: function (key, fn, last) {
                        var event = this.create()
                        event.listen(key, fn, last)
                    },
                    trigger: function () {
                        var event = this.create()
                        event.trigger.apply(this, arguments)
                    },
                }
            }()

            return myEvent
        })()

        console.log(myEvent)


        const a =function(){ return 'test'}
        console.log(a)//function(){ return 'test'}

        const a =function(){ return 'test'}()
        console.log(a)//test
    </script>
</body>